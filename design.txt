Compiling Scheme to C

HIGH LEVEL
Have an interpreter written in C for runtime
  - treat C as underlying hardware
  - treat variables as registers in an abstract machine
  - Nan tagging for efficiency

Benefits
  - able to do compiler optimizations
  - able to be extended to have low level operations

Scheme code is passed to the SICP compiler, producing a simple register machine version.
The intermediate representation is then compiled to C.
The C code is wrapped around a minimal scheme library (in c).
TODO: the rest of scheme can be implemented on top, in scheme.
The final C code is then compiled into an executable.


TYPES
via Nan tagging:
  - floats have many Nans -- let's use those to encode other types
  - 64 bit floats, IEEE 754 standard
    - 1 sign, 11 exponent, and 52 fraction bits
    - if E is all ones
      - if (= F 0) => infinity
      - else (not (= F 0)) => Nan
  - keep one of the Nans to actually be Nan
    
float
fff...ff
(not (= F 0))

integers (51 bits)
s1..11ii..i
s: s (sign bit for (signed) integer)
exp: 1s
F: 1ii..i


pointer (48 bits)
?1...10tttp..p
s: ? (unused currently)
exp: 1s
F: 0tttp..p
tags: 000 cons
      001 symbol
      010 string
      011 vector
      100 primitive procedure
      101 compound procedure
      110 address
      111 boolean  -- wasteful... have boolean be part of address?

virtual address space currently has 48 bit pointers -- enough to fit

TODO:
if sign bit is available:
for integers, use as sign -- done
for pointers, use if inline (not a pointer; data is stored directly) (for symbol, string, vector -- saves a dereference)

Internally (c), use ints as boolean values.
For the actual (scheme) code, functions will get wrapped to produce Object values (including booleans).

MODIFICATIONS TO SICP-COMPILER
- added let
- argl uses cons(val, nil) instead of list(val) for the first cons.
- replace CONTINUE register with CONT
- keep if expressions in sicp-compiler -- c can handle if expressions (no test, branch)
  - instead, use test-branch

TODO:
- quasiquote for sicp-compiler?
- compile metacircular evaluator
- optimizations
- garbage collecter

DONE OPTIMIZATIONS:
- inlined some functions

OPTIMIZATIONS:
SICP:
- open-coding primitives
- lexical addressing
  - can completely compile away environment?
    - the only defines that matter are top-level defines
    - if so, lookup-variable-value is totally obsolete
- have argl construct an array

C:
- can stack operations be optimized away?
- make sure functions are inlined
- can make binary small by only putting functions that are needed into the env
  - including scheme library and c primitives (?)
- make a primitive env -- an array -- and create it compiled from scheme
- interleave cars and cdrs -- spatial locality
  - and have a cons Object be a pointer (saves 1 add for car)
  - potentially halves cache misses (?)
- multithreading
  - makes code more complicated
  
NOTES:
- binaries can currently be made pretty small. Stripping binaries:
  - "Hello world" in C is 14.14k.
  - Compiling for size, (display "Hello world") is 14.25k

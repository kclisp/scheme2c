Compiling Scheme to C

HIGH LEVEL
Have an interpreter written in C for runtime
  - treat C as underlying hardware
  - treat variables as registers in an abstract machine
  - Nan tagging for efficiency

Benefits
  - able to do compiler optimizations
  - able to be extended to have low level operations

Scheme code is passed to the SICP compiler, producing a simple register machine version.
The intermediate representation is then compiled to C.
The C code is wrapped around a minimal scheme library (in c).
TODO: the rest of scheme can be implemented on top, in scheme.
The final C code is then compiled into an executable.


TYPES
via Nan tagging:
  - floats have many Nans -- let's use those to encode other types
  - 64 bit floats, IEEE 754 standard
    - 1 sign, 11 exponent, and 52 fraction bits
    - if E is all ones
      - if (= F 0) => infinity
      - else (not (= F 0)) => Nan
  - keep one of the Nans to actually be Nan
    
float
fff...ff
(not (= F 0))

integers (51 bits)
s1..11ii..i
s: s (sign bit for (signed) integer)
exp: 1s
F: 1ii..i


pointer (48 bits)
?1...10tttp..p
s: ? (unused currently)
exp: 1s
F: 0tttp..p
tags: 000 cons
      001 symbol
      010 string
      011 vector
      100 primitive procedure
      101 compound procedure
      110 address
      111 boolean  -- wasteful... have boolean be part of address?

virtual address space currently has 48 bit pointers -- enough to fit

TODO:
if sign bit is available:
for integers, use as sign -- done
for pointers, use if inline (not a pointer; data is stored directly) (for symbol, string, vector)

Internally (c), use ints as boolean values.
For the actual (scheme) code, functions will get wrapped to produce Object values (including booleans).

MODIFICATIONS TO SICP-COMPILER
- added let
- argl uses cons(val, nil) instead of list(val) for the first cons.
- replace CONTINUE register with CONT

TODO:
- keep if expressions in sicp-compiler -- c can handle if expressions (no test branch)
- quasiquote for sicp-compiler?

Compiling Scheme to C

HIGH LEVEL
Have an interpreter written in C for runtime
  - treat C as underlying hardware
  - treat variables as registers in an abstract machine
  - Nan tagging for efficiency

Benefits
  - able to do compiler optimizations
  - able to be extended to have low level operations

Have the base library written in C
Use SICP's compiler as an intermediate; compile the output to C

TYPES
via Nan tagging:
  - floats have many Nans -- let's use those to encode other types
  - 64 bit floats, IEEE 754 standard
    - 1 sign, 11 exponent, and 52 fraction bits
    - if E is all ones
      - if (= F 0) => infinity
      - else (not (= F 0)) => Nan
  - keep one of the Nans to actually be Nan
    
float
fff...ff
(not (= F 0))

integers (51 bits)
s1..11ii..i
s: s (sign bit for (signed) integer)
exp: 1s
F: 1ii..i


pointer (48 bits)
?1...10tttp..p
s: ? (unused currently)
exp: 1s
F: 0tttp..p
tags: 000 cons
      001 symbol
      010 string
      011 vector
      100 primitive procedure
      101 compound procedure
      110 address
      111 boolean  -- wasteful... have boolean be part of address?

virtual address space currently has 48 bit pointers -- enough to fit

TODO:
if sign bit is available:
for integers, use as sign -- done
for pointers, use if inline (not a pointer; data is stored directly) (for symbol, string, vector)

Internally (c), use ints as boolean values.
For the actual (scheme) code, functions will get wrapped to produce Object values (including booleans).

MODIFICATIONS TO SICP-COMPILER
- added let
- add new register ENTRY for going to compiled procedure entry (simpler than using val as the reigster for that)
- argl uses cons(val, nil) instead of list(val) for the first cons.
- replace CONTINUE register with CONT

TODO:
- keep if expressions in sicp-compiler -- c can handle if expressions (no test branch)

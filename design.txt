Compiling Scheme to C

HIGH LEVEL
Have an interpreter written in C for runtime
  - treat C as underlying hardware
  - treat variables as registers in an abstract machine
  - Nan tagging for efficiency

Benefits
  - able to do compiler optimizations
  - able to be extended to have low level operations

Scheme code is passed to the SICP compiler, producing a simple register machine version.
The intermediate representation is then compiled to C.
The C code is wrapped around a minimal scheme library (in c).
TODO: the rest of scheme can be implemented on top, in scheme.
The final C code is then compiled into an executable.


TYPES
via Nan tagging:
  - floats have many Nans -- let's use those to encode other types
  - 64 bit floats, IEEE 754 standard
    - 1 sign, 11 exponent, and 52 fraction bits
    - if E is all ones
      - if (= F 0) => infinity
      - else (not (= F 0)) => Nan
  - keep one of the Nans to actually be Nan
    
float
fff...ff
(not (= F 0))

integers (51 bits)
s1..11ii..i
s: s (sign bit for (signed) integer)
exp: 1s
F: 1ii..i


pointer (48 bits)
?1...10tttp..p
s: ? (unused currently)
exp: 1s
F: 0tttp..p
tags: 000 cons
      001 symbol
      010 string
      011 vector
      100 primitive procedure
      101 compound procedure
      110 address
      111 boolean  -- wasteful... have boolean be part of address?

virtual address space currently has 48 bit pointers -- enough to fit

MODIFICATIONS TO SICP-COMPILER
- added let
- argl uses cons(val, nil) instead of list(val) for the first cons.
- replace CONTINUE register with CONT
- keep if expressions in sicp-compiler -- c can handle if expressions (no test, branch)
  - instead, use test-branch
- separate macroexpansions step
- lexical addressing


GOALS:
- compile metacircular evaluator
- same speed or faster compared to compiled mit scheme
  - currently numerical programs (ack)
  
TODO:
- quasiquote for sicp-compiler?
- optimizations
- garbage collecter

DONE OPTIMIZATIONS:
- inlined some functions
- lexical addressing
  - completely compile away environment
    - the only defines that matter are top-level defines
    - lookup-variable-value is replaced with lexical-address-lookup

OPTIMIZATIONS:
SICP:
- open-coding primitives
- have argl construct an array
- procedure application -- should compile operands first -- then no need to save proc

C:
- can stack operations be optimized away?
- make sure functions are inlined
- can make binary small by only putting functions that are needed into the env
  - including scheme library and c primitives (?)
- create the primitive env array from scheme -- only needed primitives
  - with lexical addressing, this doesn't save much though
- symbol table should be created at compile time
- inline pointer data into the Object (saves a dereference) (but then what about eqp?)
- interleave cars and cdrs -- spatial locality
  - and have a cons Object be a pointer (saves 1 add for car)
  - potentially halves cache misses (?)
- multithreading
  - makes code more complicated

NOTES:
- binaries can currently be made pretty small. Stripping binaries:
  - "Hello world" in C is 14.14k.
  - Compiling for size, (display "Hello world") is 14.25k
